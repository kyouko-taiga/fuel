import AST
import Basic

/// A static analysis pass that checks the type of every statement.
///
/// This pass assumes the semantic types of declarations and signatures has been fully realized.
public final class TypeChecker: Visitor {

  /// Creates a type checker pass.
  ///
  /// - Parameter context: The compiler context in which the pass is ran.
  public init(compilerContext: CompilerContext) {
    self.compilerContext = compilerContext
  }

  /// The compiler context in which the pass is ran.
  private let compilerContext: CompilerContext

  /// The current typing context.
  private var gamma: TypingContext = [:]

  /// The function being type-checked.
  ///
  /// This property is used during the AST traversal to access the declaration of the function
  /// being type-checked.
  private var funcDecl: FuncDecl!

  /// The type of the function being type-checked.
  private var funcType: FuncType!

  public func visit(_ node: Module) {
    // Create an initial a typing context, with one entry for each type and function declaration.
    var context: TypingContext = [:]
    for decl in node.funcDecls {
      context[Symbol(decl: decl)] = decl.type
    }

    // Type-check each function declaration.
    for decl in node.funcDecls {
      gamma = context
      decl.accept(self)
    }
  }

  public func visit(_ node: BraceStmt) {
    // Type-check each statement in the block.
    var namedDecls: [NamedDecl] = []
    for stmt in node.stmts {
      stmt.accept(self)

      // Keep track of the named declarations so that they can be removed from the context later.
      if let decl = stmt as? NamedDecl {
        namedDecls.append(decl)
      }
    }

    // Remove from the context the names and memory locations that are scoped by the block.
    for decl in namedDecls {
      let symbol = Symbol(decl: decl)

      if decl is ScopeAllocStmt,
         let a = (gamma[symbol]?.bareType as? LocationType)?.location
      {
        gamma[a] = nil
      }

      gamma[symbol] = nil
    }
  }

  public func visit(_ node: CallStmt) {
    do {
      try typeCheck(node)
    } catch let error as TypeError {
      error.report(in: compilerContext)
    } catch {
      compilerContext.report(message: String(describing: error))
    }
  }

  public func typeCheck(_ node: CallStmt) throws {
    // Determine the type of the value callee.
    let funcType: FuncType
    let quantifiedParams: [QuantifiedParam]

    switch try type(of: node.ident).bareType {
    case let ft as FuncType:
      funcType = ft
      quantifiedParams = []

    case let ut as UniversalType where ut.base is FuncType:
      // swiftlint:disable:next force_cast
      funcType = ut.base as! FuncType
      quantifiedParams = ut.params

    case let t:
      throw TypeError.callToNonFunctionType(expr: node.ident, type: t)
    }

    // Pair each argument's type with the corresponding parameter's type to build the set of typing
    // constraints that's used to instantiate the function's signature.
    var solver = TypeSolver(context: gamma, constraints: [], quantifiedParams: quantifiedParams)
    for (arg, param) in zip(node.args, funcType.params) {
      do {
        let lhs = try type(of: arg)
        solver.constraints.append(TypeSolver.Constraint(lhs: .type(lhs), rhs: .type(param)))
      } catch let error as TypeError {
        error.report(in: compilerContext)
      }
    }

    // Solve the typing constraints.
    guard let assumptions = solver.solve() else {
      let argTypes = node.args.map({ arg in try? type(of: arg) })
      throw TypeError.invalidCallArgTypes(funcIdent: node.ident, argTypes: argTypes)
    }

    // Consume the assumptions required by the function.
    for assumption in assumptions where assumption.key.isReferringToLocation {
      assert(gamma[assumption.key]! <= assumption.value)
      gamma[assumption.key] = nil
    }

    // Produce the assumptions generated by the function.
    let output = funcType.output.substituting(solver.substitutions)
    if let (tau, eta) = output.opened {
      gamma[Symbol(decl: node)] = tau
      for assumption in eta {
        assert(gamma[assumption.key] == nil)
        gamma[assumption.key] = assumption.value
      }
    } else {
      gamma[Symbol(decl: node)] = output
    }
  }

  public func visit(_ node: FuncDecl) {
    // Skip the declaration if it's just a prologue.
    guard let body = node.body else {
      return
    }

    // The unqualified, canonical form of `declType` must be a function type or a universally
    // quantified function type. In the latter case, we can remove the universal quantier and
    // "instanciate" the function type.
    let declType: FuncType
    switch node.type?.bareType {
    case let ft as FuncType:
      declType = ft

    case let ut as UniversalType:
      guard let ft = ut.base as? FuncType else { return }
      declType = ft

    default:
      // Skip the declaration if it doesn't have a valid function type. This can be done silently,
      // as it should only happen when the type realizer was not able to evaluate an appropriate
      // type, which would have resulted in a diagnostic.
      return
    }

    // Setup the typing context to check the function's implementation.
    funcDecl = node
    funcType = declType

    for param in node.params {
      guard let paramType = param.type else {
        continue
      }

      let symbol = Symbol(decl: param)
      if let (tau, eta) = param.type?.opened {
        // Unpack the parameter type.
        gamma[symbol] = tau

        // Check that each packed assumption either adds a new binding, or agrees with the context.
        for assumption in eta {
          if let tau = gamma[assumption.key], tau != assumption.value {
            compilerContext.report(message: "type of parameter '\(param.name)' is inconsistent")
              .set(location: param.range?.lowerBound)
              .add(range: param.range)
          } else {
            gamma[assumption.key] = assumption.value
          }
        }
      } else {
        gamma[symbol] = paramType
      }
    }

    body.accept(self)
  }

  public func visit(_ node: FreeStmt) {
    // Determine the type of the identifier being deallocated.
    node.ident.accept(self)

    // Extract a capability `[a: loose τ]`.
    fatalError("todo")
  }

  public func visit(_ node: IfStmt) {
    do {
      try typeCheck(node)
    } catch let error as TypeError {
      error.report(in: compilerContext)
    } catch {
      compilerContext.report(message: String(describing: error))
    }
  }

  public func typeCheck(_ node: IfStmt) throws {
    // Visit the node's condition.
    node.cond.accept(self)

    // Check that the condition is a subtype of Bool.
    let tau = try type(of: node.cond)
    guard tau <= BuiltinType.bool.qualified() else {
      throw TypeError.invalidTypeConversion(
        t1: tau,
        t2: BuiltinType.bool.qualified(),
        range: node.cond.range)
    }

    // Type both branches of the statement individually.
    let context = gamma
    node.thenBody.accept(self)
    let thenContext = gamma

    gamma = context
    node.elseBody?.accept(self)

    // Join the resulting contexts.
    gamma = join(thenContext, gamma)
  }

  private func join(_ lhs: TypingContext, _ rhs: TypingContext) -> TypingContext {
    // Trivially, if both contexts are empty, then their join is an empty context.
    if lhs.isEmpty && rhs.isEmpty {
      return lhs
    }

    // FIXME: If the contexts' domains don't match, find a substitution for the new addresses to
    // heap-allocated in rhs that minimizes the difference.

    let lhsKeys = Set(lhs.keys)
    let rhsKeys = Set(rhs.keys)

    // Compute the join of all matching assumptions.
    let newContext = TypingContext(
      uniqueKeysWithValues: lhsKeys.intersection(rhsKeys).map({ key in
        (key: key, value: lhs[key]!.join(with: rhs[key]!))
      }))

    // FIXME: Create "uncertain" assumptions for each mismatching pair, to denote irreconcilable
    // outcomes. These will have to be consumed by dynamic checks.

    return newContext
  }

  public func visit(_ node: LoadStmt) {
    do {
      try typeCheck(node)
    } catch let error as TypeError {
      error.report(in: compilerContext)
    } catch {
      compilerContext.report(message: String(describing: error))
    }
  }

  public func typeCheck(_ node: LoadStmt) throws {
    // Determine the type of the value reference.
    let nodeType = try type(of: node.valueRef)

    // There are two cases to consider; the first is when the l-value is an identifier, the second
    // is when it's a member expression. In either case, the type of the l-value should be `!a`
    // for some location `a`.
    guard let loc = (nodeType.bareType as? LocationType)?.location else {
      throw TypeError.invalidLValue(expr: node.valueRef)
    }

    // Check if we hold a capability `[a: τ]`.
    guard let tau = gamma[loc] else {
      throw TypeError.missingCapability(
        symbol: loc,
        type: BuiltinType.any.qualified(by: []),
        range: node.range)
    }

    gamma[Symbol(decl: node)] = tau
  }

  public func visit(_ node: ReturnStmt) {
    do {
      try typeCheck(node)
    } catch let error as TypeError {
      error.report(in: compilerContext)
    } catch {
      compilerContext.report(message: String(describing: error))
    }
  }

  public func typeCheck(_ node: ReturnStmt) throws {
    // Determine the type of the return value.
    let returnValueType = try type(of: node.value)

    // Check that the type of the return value matches the function's output type.
    let outputType: QualType
    let assumptions: TypingContext

    if let (tau, eta) = funcType.output.opened {
      outputType = tau
      assumptions = eta
    } else {
      outputType = funcType.output
      assumptions = [:]
    }

    guard returnValueType.isSubtype(of: outputType) else {
      throw TypeError.invalidTypeConversion(
        t1: returnValueType,
        t2: outputType,
        range: node.value.range)
    }

    // Verity that the the environment contains the assumptions described by the function's
    // return type.
    for assumption in assumptions {
      guard let tau = gamma[assumption.key] else {
        TypeError
          .missingCapability(symbol: assumption.key, type: assumption.value, range: node.range)
          .report(in: compilerContext)
        continue
      }

      guard tau <= assumption.value else {
        TypeError
          .invalidAssumptionConversion(
            a1: (assumption.key, tau),
            a2: assumption,
            range: node.range)
          .report(in: compilerContext)
        continue
      }
    }
  }

  public func visit(_ node: ScopeAllocStmt) {
    typeCheck(node)
  }

  public func typeCheck(_ node: ScopeAllocStmt) {
    // Determine the new storage's memory layout.
    guard let storageType = node.sign.type else {
      // Skip the declaration if it's type is undefined. This can be done silently, as it should
      // only happen when the type realizer was not able to evaluate an appropriate type, which
      // would have resulted in a diagnostic.
      return
    }

    // Allocate a new location and create a capacity for it.
    let a = alloc()
    gamma[Symbol(decl: node)] = LocationType(location: a).qualified()
    gamma[a] = JunkType(base: storageType.bareType).qualified(by: storageType.quals)
  }

  public func visit(_ node: StoreStmt) {
    do {
      try typeCheck(node)
    } catch let error as TypeError {
      error.report(in: compilerContext)
    } catch {
      compilerContext.report(message: String(describing: error))
    }
  }

  public func typeCheck(_ node: StoreStmt) throws {
    // Determine the types of the l-value and r-value.
    let rvType = try type(of: node.rvalue)
    let lvType = try type(of: node.lvalue)

    // The target identifier should have type `!a`.
    guard let loc = (lvType.bareType as? LocationType)?.location else {
      throw TypeError.invalidLValue(expr: node.lvalue)
    }

    // Check that we have the capability to write at `a`.
    guard var storageType = gamma[loc] else {
      throw TypeError.missingCapability(
        symbol: loc,
        type: BuiltinType.any.qualified(),
        range: node.range)
    }

    // Check that τ's layout is compatible with the value to store.
    if let junk = storageType.bareType as? JunkType {
      storageType = junk.base.qualified(by: storageType.quals)
    }
    guard rvType.isSubtype(of: storageType) else {
      throw TypeError.invalidTypeConversion(t1: rvType, t2: storageType, range: node.rvalue.range)
    }

    gamma[loc] = rvType
  }

  // MARK: Helper functions.

  private var nextLocationID = 0

  private func alloc() -> Symbol {
    let symbol = Symbol(id: nextLocationID, isReferringToLocation: true)
    nextLocationID += 1
    return symbol
  }

  /// Implements `Γ ⊢ e : τ`.
  private func type(of e: Expr) throws -> QualType {
    switch e {
    case is BoolLit:
      return BuiltinType.bool.qualified()

    case is IntLit:
      return BuiltinType.int.qualified()

    case is VoidLit:
      return BuiltinType.void.qualified()

    case let ident as IdentExpr:
      guard let decl = ident.referredDecl else {
        throw TypeError.undefinedExprType(expr: e)
      }
      guard let type = gamma[Symbol(decl: decl)] else {
        throw TypeError.undefinedExprType(expr: e)
      }
      return type

    case let member as MemberExpr:
      let bareType: BareType

      switch try type(of: member.base).bareType {
      case let junk as JunkType:
        bareType = junk.base
      case let t:
        bareType = t
      }

      guard let tupleType = bareType as? TupleType else {
        throw TypeError.memberAccessInScalarType(expr: e, type: bareType)
      }
      guard member.offset < tupleType.members.count else {
        throw TypeError.invalidMemberOffset(expr: e)
      }
      return tupleType.members[member.offset]

    default:
      throw TypeError.undefinedExprType(expr: e)
    }
  }

}
